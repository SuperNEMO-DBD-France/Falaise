//  falaise/app/metadata_utils.cc

// Ourselves
#include "falaise/app/metadata_utils.h"

// Third party:
// - Bayeux:
#include <bayeux/dpp/input_module.h>

// This Project
#include "falaise/configuration_db.h"

namespace falaise {

  namespace app {

    void metadata_input::reset()
    {
      userProfile = "";
      experimentalSetupUrn = "";
      variantConfigUrn = "";
      variantConfigPath = "";
      variantProfileUrn = "";
      variantProfilePath = "";
      variantProfileUrn = "";
      variantProfilePath = "";
      variantSettings.clear();
      servicesConfigPath = "";
      variantProfilePath = "";
      numberOfEvents = 0;
      doSimulation = false;
      simuSetupUrn = "";
      doDigitization = false;
      digiSetupUrn = "";
      doReconstruction = false;
      recSetupUrn = "";
      return;
    }

    void metadata_input::print(std::ostream & out_) const
    {
      static const std::string tag("|-- ");
      static const std::string last_tag("`-- ");
      out_ << "Input metadata of interest: " << std::endl;
      out_ << tag
           << "userProfile           = " << userProfile << std::endl;
      out_ << tag
           << "experimentalSetupUrn  = " << experimentalSetupUrn << std::endl;
      out_ << tag
           << "variantConfigUrn      = " << variantConfigUrn << std::endl;
      out_ << tag
           << "variantConfigPath     = " << variantConfigPath << std::endl;
      out_ << tag
           << "variantProfileUrn     = " << variantProfileUrn << std::endl;
      out_ << tag
           << "variantProfilePath    = " << variantProfilePath << std::endl;
       out_ << tag
           << "servicesConfigUrn     = " << servicesConfigUrn << std::endl;
      out_ << tag
           << "servicesConfigPath    = " << servicesConfigPath << std::endl;
      out_ << tag
           << "numberOfEvents        = " << numberOfEvents << std::endl;
      out_ << tag
           << "doSimulation          = " << std::boolalpha << doSimulation << std::endl;
      out_ << tag
           << "simuSetupUrn          = " << simuSetupUrn << std::endl;
      out_ << tag
           << "doDigitization        = " << std::boolalpha << doDigitization << std::endl;
      out_ << tag
           << "digiSetupUrn          = " << digiSetupUrn << std::endl;
      out_ << tag
           << "doReconstruction      = " << std::boolalpha << doReconstruction << std::endl;
      out_ << last_tag
           << "recSetupUrn           = " << recSetupUrn << std::endl;
      return;
    }

    void metadata_input::scan(const datatools::multi_properties & mp_)
    {
      falaise::configuration_db cfgdb;
      if (mp_.empty()) {
        return;
      }
      metadata_scanner ms(mp_);

      // Input metadata from FLSimulate
      if (ms.check_section("flsimulate", "flsimulate::section")) {
        // DT_LOG_DEBUG(logging, "Input metadata were generated by FLSimulate");
        ms.find_string ("flsimulate", "flsimulate::section", "userProfile",          this->userProfile);
        ms.find_string ("flsimulate", "flsimulate::section", "experimentalSetupUrn", this->experimentalSetupUrn);
        ms.find_size   ("flsimulate", "flsimulate::section", "numberOfEvents",       this->numberOfEvents);
        ms.find_boolean("flsimulate", "flsimulate::section", "doSimulation",         this->doSimulation);
        ms.find_boolean("flsimulate", "flsimulate::section", "doDigitization",       this->doDigitization);

        // Simulation section:
        if (this->doSimulation && ms.check_section("flsimulate.simulation", "flsimulate::section")) {
          ms.find_string("flsimulate.simulation", "flsimulate::section", "simulationSetupUrn", this->simuSetupUrn);
        }

        // Digitization section:
        if (this->doDigitization && ms.check_section("flsimulate.digitization", "flsimulate::section")) {
          ms.find_string("flsimulate.digitization", "flsimulate::section", "digitizationSetupUrn", this->digiSetupUrn);
        }

        // Variants section:
        if (this->doSimulation && ms.check_section("flsimulate.variants", "flsimulate::section")) {
          ms.find_string ("flsimulate.variants", "flsimulate::section", "configUrn",  this->variantConfigUrn);
          ms.find_path   ("flsimulate.variants", "flsimulate::section", "config",     this->variantConfigPath);
          ms.find_string ("flsimulate.variants", "flsimulate::section", "profileUrn", this->variantProfileUrn);
          ms.find_path   ("flsimulate.variants", "flsimulate::section", "profile",    this->variantProfilePath);
          ms.find_strings("flsimulate.variants", "flsimulate::section", "settings",   this->variantSettings);
        }

        // Service section:
        if (this->doSimulation && ms.check_section("flsimulate.services", "flsimulate::section")) {
          ms.find_string ("flsimulate.services", "flsimulate::section", "configUrn", this->servicesConfigUrn);
          ms.find_path   ("flsimulate.services", "flsimulate::section", "config",    this->servicesConfigPath);
        }

        // If no experimental setup identifier/URN is set:
        if (this->experimentalSetupUrn.empty() && !this->simuSetupUrn.empty()) {
          // Then try to fetch the simulation setup identifier/URN:
          std::string conf_category = falaise::configuration_db::category::simulation_setup_label();
          DT_THROW_IF(!cfgdb.check_with_category(this->simuSetupUrn, conf_category),
                      std::logic_error,
                      "Cannot query simulation setup URN='" << this->simuSetupUrn << "'!");
          // and extract the associated 'experimentalSetupUrn':
          std::string expsetup_dependee;
          if (cfgdb.find_direct_unique_dependee_with_category_from(expsetup_dependee,
                                                                   this->simuSetupUrn,
                                                                   falaise::configuration_db::category::experimental_setup_label())) {
            this->experimentalSetupUrn = expsetup_dependee;
          }
        }
        if (this->experimentalSetupUrn.empty() && !this->digiSetupUrn.empty()) {
          // Then try to fetch the digitization setup identifier/URN:
          std::string conf_category = falaise::configuration_db::category::digitization_setup_label();
          DT_THROW_IF(!cfgdb.check_with_category(this->digiSetupUrn, conf_category),
                      std::logic_error,
                      "Cannot query URN='" << this->digiSetupUrn << "'!");
          // and extract the associated 'experimentalSetupUrn':
          std::string expsetup_dependee;
          if (cfgdb.find_direct_unique_dependee_with_category_from(expsetup_dependee,
                                                                   this->digiSetupUrn,
                                                                   falaise::configuration_db::category::experimental_setup_label())) {
            this->experimentalSetupUrn = expsetup_dependee;
          }
        }

      } // Input metadata from FLSimulate

      // Input metadata from FLReconstruct
      if (ms.check_section("flreconstruct", "flreconstruct::section")) {
        this->doReconstruction = true;
        // DT_LOG_DEBUG(logging, "Input metadata were generated by FLReconstruct");
        ms.find_string("flreconstruct", "flreconstruct::section", "userProfile",          this->userProfile);
        ms.find_string("flreconstruct", "flreconstruct::section", "experimentalSetupUrn", this->experimentalSetupUrn);
        ms.find_size  ("flreconstruct", "flreconstruct::section", "numberOfEvents",       this->numberOfEvents);

        // Reconstruction section:
        if (this->doReconstruction && ms.check_section("flreconstruct.pipeline", "flreconstruct::section")) {
          ms.find_string("flreconstruct.pipeline", "flreconstruct::section", "configUrn", this->recSetupUrn);
        }

        // If no experimental setup identifier/URN is set:
        if (this->experimentalSetupUrn.empty() && !this->recSetupUrn.empty()) {
          // Then try to fetch the reconstruction setup identifier/URN:
          std::string conf_category = falaise::configuration_db::category::reconstruction_setup_label();
          DT_THROW_IF(!cfgdb.check_with_category(this->recSetupUrn, conf_category),
                      std::logic_error,
                      "Cannot check URN='" << this->recSetupUrn << "'!");
          // and extract the associated 'experimentalSetupUrn':
          std::string expsetup_dependee;
          if (cfgdb.find_direct_unique_dependee_with_category_from(expsetup_dependee,
                                                                   this->recSetupUrn,
                                                                   falaise::configuration_db::category::experimental_setup_label())) {
            this->experimentalSetupUrn = expsetup_dependee;
          }
        }

        // Variants section:
        if (this->doSimulation && ms.check_section("flreconstruct.variants", "flreconstruct::section")) {
          ms.find_string ("flreconstruct.variants", "flreconstruct::section", "configUrn",  this->variantConfigUrn);
          ms.find_path   ("flreconstruct.variants", "flreconstruct::section", "config",     this->variantConfigPath);
          ms.find_string ("flreconstruct.variants", "flreconstruct::section", "profileUrn", this->variantProfileUrn);
          ms.find_path   ("flreconstruct.variants", "flreconstruct::section", "profile",    this->variantProfilePath);
          ms.find_strings("flreconstruct.variants", "flreconstruct::section", "settings",   this->variantSettings);
        }

        // Service section:
        if (this->doSimulation && ms.check_section("flreconstruct.services", "flreconstruct::section")) {
          ms.find_string ("flreconstruct.services", "flreconstruct::section", "configUrn", this->servicesConfigUrn);
          ms.find_path   ("flreconstruct.services", "flreconstruct::section", "config",    this->servicesConfigPath);
        }

      } // Input metadata from FLReconstruct

      return;
    }

    metadata_collector::metadata_collector(const uint32_t /*flags_*/)
    {
    }

    void metadata_collector::set_input_data_file(const std::string & idf_)
    {
      _input_data_file_ = idf_;
    }

    void metadata_collector::set_input_metadata_file(const std::string & imf_)
    {
      _input_metadata_file_ = imf_;
    }

    datatools::multi_properties
    metadata_collector::get_metadata_from_data_file() const
    {
      // Metadata is currently available as soon as the input module is initialized.
      std::unique_ptr<dpp::input_module> inputMod(new dpp::input_module);
      std::string dfile(_input_data_file_);
      datatools::fetch_path_with_env(dfile);
      inputMod->set_single_input_file(dfile);
      // Input metadata management:
      const datatools::multi_properties& iMetadataStore = inputMod->get_metadata_store();
      inputMod->initialize_simple();
      datatools::multi_properties md;
      md.clear_key_label();
      md.clear_meta_label();
      md = iMetadataStore;
      return md;
    }

    datatools::multi_properties
    metadata_collector::get_metadata_from_metadata_file() const
    {
      std::string mdfile = _input_metadata_file_;
      datatools::fetch_path_with_env(mdfile);
      datatools::multi_properties md;
      md.clear_key_label();
      md.clear_meta_label();
      md.read(mdfile);
      return md;
    }

    datatools::multi_properties
    metadata_collector::get_metadata() const
    {
      datatools::multi_properties md;
      return md;
    }

    metadata_scanner::metadata_scanner(const datatools::multi_properties & mp_)
      : _mp_(mp_)
    {
      return;
    }

    bool metadata_scanner::_find_data_in_section_(const std::string & section_name_,
                                                  const std::string & section_type_,
                                                  const std::string & propKey_,
                                                  datatools::properties::data & data_) const
    {
      if (!check_section(section_name_, section_type_)) {
        return false;
      }
      const datatools::properties & aSection = _mp_.get_section(section_name_);
      if (!aSection.has_key(propKey_)) {
        return false;
      }
      data_ = aSection.get(propKey_);
      return true;
    }

    bool metadata_scanner::check_section(const std::string & section_name_,
                                         const std::string & section_type_) const
    {
      if (_mp_.empty()) return false;
      if (!_mp_.has_key_with_meta(section_name_, section_type_)) {
        return false;
      }
      return true;
    }

    const datatools::properties &
    metadata_scanner::get_section(const std::string & section_name_,
                                  const std::string & /*section_type_*/) const
    {
      return _mp_.get_section(section_name_);
    }

    bool metadata_scanner::find_boolean(const std::string & section_name_,
                                        const std::string & section_type_,
                                        const std::string & propKey_,
                                        bool & propValue_) const
    {
      datatools::properties::data d;
      if (!_find_data_in_section_(section_name_, section_type_, propKey_, d)) {
        return false;
      }
      if (!d.is_boolean()) return false;
      propValue_ = d.get_boolean_value();
      return true;
    }

    bool metadata_scanner::find_path(const std::string & section_name_,
                                     const std::string & section_type_,
                                     const std::string & propKey_,
                                     std::string & propValue_) const
    {
      datatools::properties::data d;
      if (!_find_data_in_section_(section_name_, section_type_, propKey_, d)) {
        return false;
      }
      if (!d.is_path()) return false;
      propValue_ = d.get_string_value();
      return true;
    }

    bool metadata_scanner::find_string(const std::string & section_name_,
                                       const std::string & section_type_,
                                       const std::string & propKey_,
                                       std::string & propValue_) const
    {
      datatools::properties::data d;
      if (!_find_data_in_section_(section_name_, section_type_, propKey_, d)) {
        return false;
      }
      if (!d.is_string()) return false;
      propValue_ = d.get_string_value();
      return true;
    }

    bool metadata_scanner::find_strings(const std::string & section_name_,
                                        const std::string & section_type_,
                                        const std::string & propKey_,
                                        std::vector<std::string> & propValues_) const
    {
      datatools::properties::data d;
      if (!_find_data_in_section_(section_name_, section_type_, propKey_, d)) {
        return false;
      }
      if (!d.is_vector()) return false;
      if (!d.is_string()) return false;
      propValues_.clear();
      propValues_.reserve(d.get_size());
      for (std::size_t i = 0; i < (std::size_t) d.get_size(); i++) {
        propValues_.push_back(d.get_string_value(i));
      }
      return true;
    }

    bool metadata_scanner::find_size(const std::string & section_name_,
                                     const std::string & section_type_,
                                     const std::string & propKey_,
                                     std::size_t & propValue_) const
    {
      datatools::properties::data d;
      if (!_find_data_in_section_(section_name_, section_type_, propKey_, d)) {
        return false;
      }
      if (!d.is_integer()) return false;
      propValue_ = (std::size_t) d.get_integer_value();
      return true;
    }

    bool metadata_scanner::find_integer(const std::string & section_name_,
                                        const std::string & section_type_,
                                        const std::string & propKey_,
                                        int & propValue_) const
    {
      datatools::properties::data d;
      if (!_find_data_in_section_(section_name_, section_type_, propKey_, d)) {
        return false;
      }
      if (!d.is_integer()) return false;
      propValue_ = d.get_integer_value();
      return true;
    }

    bool metadata_scanner::find_real(const std::string & section_name_,
                                        const std::string & section_type_,
                                        const std::string & propKey_,
                                        double & propValue_) const
    {
      datatools::properties::data d;
      if (!_find_data_in_section_(section_name_, section_type_, propKey_, d)) {
        return false;
      }
      if (!d.is_real()) return false;
      propValue_ = d.get_real_value();
      return true;
    }

  } // namespace app

} // namespace falaise
